## 定位函数
以下算法基于顺序存储的字符串结构，且利用第一个存储单元存放字符串的长度。

整体思路：
1. 将指针指向主串的第`pos`位和子串的第一位，准备匹配。
2. 逐个移动指针，如果指向的内容相同，则继续向后移动。
3. 如果指向的内容不同，指向子串的指针回到第一位，指向主串的指针回退`j-2`位（与原本第一次成功开始匹配的位置差`j-1`位，而该位已不可能匹配成功，因此向后移动到`j-2`位）
4. 匹配结束后，若指向子串的指针仍然指向子串，意味着还有内容未被匹配到，即匹配失败；否则当前位置向前移动`t`的长度，即为子串开始的位置。

```c
int Index(SString s, SString t, int pos) {
    // 返回子串t在主串s中第pos个字符之后的位置 若不存在则返回0
    i = pos, j = 1;
    while(i <= s[0] && j <= t[0]) {
        if(s[i] == t[j]) {
            ++i;
            ++j; // 继续匹配
        } else {
            i = i - j + 2;
            j = 1; // 重新匹配
        }
    }
    if(j > t[0]) {
        return (i - t[0]); // 当前位置减去子串的长度 就是子串开始的位置
    } else {
        return 0; // 被匹配的长度小于子串长度，即子串没有被完全匹配
    }
}
```


## KMP
KMP可以在 $O(n+m)$ 的时间完成模式匹配操作。当出现**失配**时，KMP算法将模式串 $p$ （子串）移动一段尽可能远的距离再进行比较。

设主串 $s = '{s_1s_2s_3...s_n}'$ ， 模式串 $p = '{p_1p_2p_3...p_m}'$ 。要考虑的问题是：当匹配过程中产生失配（ $s_i \neq p_j$ )，接下来应该选择主串的哪个字符和模式串的哪个字符开始比较。

假设应该从模式串的第 $k(k < j)$ 个字符继续比较，那么存在一个**最大**的 $k$ ，满足：

$$'{p_1p_2...p_{k-1}}' = '{s_{i-k+1}s_{i-k+2}...s_{i-1}}'$$

已经得到的部分匹配可以得出：

$$'{p_{j-k+1}p_{j-k+2}...p_{j-1}}' = '{s_{i-k+1}s_{i-k+2}...s_{i-1}}'$$

根据两式可以得出：

$$'{p_1p_2...p_{k-1}}' = '{p_{j-k+1}p_{j-k+2}...p_{j-1}}'$$ 


**反之**，若模式串中存在满足上面结论的两个子串，则在匹配中，若主串第 $i$ 个和模式串第$j$个出现不同，只需要移动模式串，使模式串第 $k$ 个和主串第 $i$ 个进行比较：模式串的前 $k-1$ 个已被确认和主串对应位置匹配，无需再次比较。


为了得到不同的$j$下符合 $'{p_1p_2...p_{k-1}}' = '{p_{j-k+1}p_{j-k+2}...p_{j-1}}'$ 的 $k$ ， 还需要**next数组**。 该数组记录了每个 $j$ 对应的 $k$ 的值。

以下是`next`函数的定义：

![](https://latex.codecogs.com/gif.latex?next%5Bj%5D%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20j%3D1%20%5C%5C%20Max%5C%7Bk%20%7C%201%3Ck%3Cj%2C%20%27%7Bp_1p_2...p_%7Bk-1%7D%7D%27%20%3D%20%27%7Bp_%7Bj-k&plus;1%7Dp_%7Bj-k&plus;2%7D...p_%7Bj-1%7D%7D%27%5C%7D%2C%20while-set-isn%27t-empty%20%5C%5C%201%2C%20others%5C%5C%20%5Cend%7Bcases%7D)


**实现：**
```c
int kmp(SString s, SString p, int pos) {
    i = pos, j = 1;
    while(i <= s[0] && j <= p[0]) {
        if(j == 0 || s[i] == p[j]) {
            ++i;
            ++j;
        } else {
            j = next[j]; // next数组稍后实现
        }
    }
    if(j > p[0]) {
        return (i-p[0]);
    } else {
        return 0;
    }
}
```

**next函数的实现:**

由定义可知：设 $next[j]=k$ ，

$$next[1]=0$$
$$'{p_1p_2...p_{k-1}}' = '{p_{j-k+1}p_{j-k+2}...p_{j-1}}' (1<k<j)$$

特殊情况下， $p_k=p_j$ ，此时根据定义可以得出：

$$'{p_1p_2...p_{k}}' = '{p_{j-k+1}p_{j-k+2}...p_{j}}'$$ 


根据 $next[j]=k$ 可得：

$$next[j+1] = k + 1 = next[j] + 1$$


若 $p_k \neq p_j$ ，可以将求`next`函数值看作以模式串自身为主串和模式串的模式匹配问题。

在将模式串与自身模式匹配的过程中，由于 $p_k \neq p_j$ ，即 $p_k$ 和 $p_j$ 比较时出现**失配**，因此应将模式串滑动到用模式串的第 $next[k]$ 个字符和主串中的第 $j$ 个字符作比较。

假设 $next[k]=k'$ ，且 $p_j=p_{k'}$ ，说明主串的**第 $j+1$ 个字符前存在一个长度为 $k'$ 的最长子串**，即：

$$'{p_1...p_{k'}}'='{p_{j-k'+1}...p_j}'$$

由此式得出：

$$next[j+1] = k' + 1 = next[k] + 1$$

当 $p_j \neq p_{k'}$ ， 则继续移动模式串，直到第 $next[k']$ 个字符和 $p_j$ 相等，直至匹配成功或结束：

$$next[j+1] = 1$$


```c
void get_next(SString p, int next[]) {
    i=1, next[1]=0, j=0;
    while(i<p[0]) {
        if(j==0 || p[i] == p[j]) {
            ++i;
            ++j;
            next[i] = j;
        } else {
            j = next[j];
        }
    }
}
```