> [请注意->](/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06.%20%E5%9B%BE/notice.md)

## 数组表示法

用两个数组分别存储数据元素的信息和数据元素之间的关系（边或弧）的信息。
```c
#define MAX_VERTEX 20 // 最大顶点个数


typedef enum {DG, DN, UDG, UDN} GraphTypes; // 枚举不同类型的图：有向图 有向网 无向图 无向网
typedef struct ArcCell {
    VRType adj; // 表示顶点关系。 带权图为权值，无权图用0或1表示是否相邻。
    InfoType *info; 
}ArcCell, AdjMatrix[MAX_VERTEX][MAX_VERTEX];

typedef struct {
    VertexType vexs[MAX_VERTEX]; // 顶点向量
    AdjMatrix arcs; // 邻接矩阵
    int vexnum; // 顶点数
    int arcnum; // 弧数
    GraphType type; // 图的类型
}Graph;
```

对于无向图，顶点 $v_i$ 显然就是邻接矩阵中第 $i$ 行（或列）的元素之和：

$$TD(v_i)=\sum_{j=0}^{n-1}A[i][j] (n = MAX\_VERTEX)$$

对于有向图， 入度是列的和，出度是行的和。

同时，由于存在权值，不能只用0和1来标记边的关系。当边存在时，存储权值；当不存在时，存储`INT_MAX`（或其他不可能出现的权值）。


### 算法
#### 构造图
```c
Status CreateGraph(Graph *g) {
    printf("Input graph type:");
    scanf(g->GraphType);
    switch(g->GraphType) {
        case DG: return CreateDG(g);
        // case DN...
        // case UDG...
        // case UDN...
    }
}
```

构造无向网UDN:
```c
Status CreateUDN(Graph *g) {
    scanf(&g->vexnum, &g->arcnum, &IncInfo);
    for(int i=0; i<g->vexnum; i++) {
        scanf(&g->vexs[i]); // 构造顶点向量
    }
    for(int i=0; i<g->vexnum; i++) {
        // 初始化邻接矩阵
        for(int j=0; j<g->vexnum; j++) {
            g->arcs[i][j] = {INT_MAX, NULL}; 
        }
    }
    for(int k=0; k<g->arcnum; k++) {
        // 构造邻接矩阵
        scanf(&v1, &v2, &w); // 边的两个顶点v和权值w
        v1_pos = LocateVertex(g, v1);
        v2_pos = LocateVertex(g, v2);
        g->arcs[v1_pos][v2_pos].adj = w; // 写入权值
        if(IncInfo) {
            *g->arcs[i][j].info = IncInfo;
        }
        g->arcs[j][i] = g->arcs[i][j]; // 无向图的对称弧
    }
    return OK;
}
```