# 图的基本操作
图的基本操作的具体实现和图选用的存储结构相关。由于具体代码实现较为复杂，只需要了解实现**思路**和复杂度等基本性质即可。

## IfAdj(G, x, y)
判断顶点 $x$ 和 $y$ 是否邻接，即是否存在边 $(x,y)$ 或弧 $<x,y>$ 。

1. 邻接矩阵： 找到矩阵中对应行列的值即可。 复杂度为 $O(1)$ 。
2. 邻接表： 需要从 $x$ 顶点出发遍历， 最坏情况下不邻接，需要遍历完全部邻接点。 复杂度为 $O(\mid V \mid)$。


## Neighbors(G, x)
列出与顶点 $x$ 所邻接的边。

### 无向图
1. 邻接矩阵： 沿行/列找出有效值的顶点即可。 复杂度为 $O(\mid V \mid)$ 。
2. 邻接表： 遍历。 复杂度为 $O(\mid V \mid)$ 。

### 有向图
1. 邻接矩阵： 同无向图。
2. 邻接表： 
    1. 出边： $O(\mid V \mid)$
    2. 入边： 需要遍历全部边结点才能找出全部入边。 复杂度为 $O(\mid E \mid)$ 。


## InsertVex(G, x)
插入新顶点 $x$ 。（没有边或弧与其相连）

1. 邻接矩阵： 新增行和列，并且新增的位置的值均为0（带权图为设定的标记值，如 `INFINITY`）
2. 邻接表： 新增顶点结点，且`firstarc`指向`NULL`。


## DeleteVex(G, x)
删除顶点 $x$ 。

1. 邻接矩阵： 将对应行列全部置0。 除此之外，还可以附设顶点结构体属性来标记该顶点为空顶点。复杂度为 $O(\mid V \mid)$ 。
2. 邻接表： 删除结点，并遍历边结点后删除。 复杂度为 $O(\mid E \mid)$ 。


## InsertArc(G, x, y)
对图的两个顶点 $x$ 和 $y$ 创建边或弧。

1. 邻接矩阵： 修改对应值。
2. 邻接表： 直接插入即可。注意有两种插入方式： **尾插和头插**。 头插的效率更高，因为无需移动到最后，复杂度 $O(1)$ ， 尾插复杂度为 $O(\mid V \mid)$ 。


## FirstAdjVex(G, x)
找出图中顶点 $x$ 的第一个邻接顶点。

### 无向图
1. 邻接矩阵： 按行/列寻找。 复杂度 $O(\mid V \mid)$ 。
2. 邻接表： 直接通过`firstarc` 得到。 复杂度 $O(1)$ 。

### 有向图
1. 邻接矩阵： 入边扫描列，出边扫描行。 复杂度为 $O(\mid V \mid)$ 。
2. 邻接表： 出边直接通过 `firstarc` 得到， 复杂度 $O(1)$ ， 入边需要遍历全部边结点， 复杂度为 $O(\mid E \mid)$ 。


## NextAdjVex(G, x, y)
找出顶点 $x$ 相对于 $y$ 之后的一个邻接顶点。

1. 邻接矩阵： 从 $y$ 之后继续寻找。复杂度为 $O(\mid V \mid)$ 。
2. 邻接表： 从 `firstarc` 指向的第一个结点往后得到， 复杂度为 $O(1)$ 。