> 习题来自： 《C语言程序设计（第4版）》 何钦铭著 高等教育出版社 ISBN 9787040545067 

## 选择题
1. 下列语句定义 px 为指向 int 类型变量的指针，正确的是（ ）。

A. int x, *px=x;

B. int x, *px=&x;

C. int *px=&x, x;

D. int x, px=x;

答案：B


2. 以下选项中，对基本类型相同的指针变量不能进行运算的运算符是（ ）。

A. =

B. ==

C. +

D. -

答案： C

解析： 基本类型相同的指针变量可以互相赋值，也可以相减，表示两个内存地址相隔的同类型**元素个数**。 相加是非法的。


3. 下列程序的输出结果是（ ）。
```c
void f(int *p)
{
	*p = 5;
}
int main(void)
{
	int x = 10, *px = &x;
	f(px);
	printf("%d#", (*px)++);
	printf("%d\n", x);
	return 0;
}
```

A.5#6

B.6#6

C.10#11

D.11#11

答案： A

解析： px为实参，p为形参，`*p=5`将实参px指向的变量改为5；`i++`为先输出后自增，因此(*px)++的值为5，自增后再打印`*px`指向的x值为6.


4. 以下程序的输出结果是（ ）。

```c
void sub(int x, int y, int *z)
{
	*z = y - x;
}
int main(void)
{
	int a, b, c;
	sub(10, 5, &a);
	sub(7, a, &b);
	sub(a, b, &c);
	printf("%d,%d,%d\n", a, b, c);
	return 0;
}
```

A.5,2, 3

B.5, -2, -7

C.-5,-12, -17

D.-5,-12, - 7

答案： D

解析：
```c
void sub(int x, int y, int *z)
{
	*z = y - x;
}
int main(void)
{
	int a, b, c;
	sub(10, 5, &a); // a = -5
	sub(7, a, &b); // b = -12
	sub(a, b, &c); // c = -7
	printf("%d,%d,%d\n", a, b, c);
	return 0;
}
```


5. 若有以下定义，且 0<=i<10 ，则对数组元素的错误引用是（ ）。

```c
int i,a[]={0,1,2,3,4,5,6,7,8,9},*p=a;
```

A. `*(a+i)`

B. `a[p-a+i]`

C. `p+i`

D. `*(&a[i])`


答案： C

解析：`p+i`的类型是指针，要表示数组元素，应使用`*`。


6. 下列程序段的输出结果是（ ）。

```c
int a[10]={0,1,2,3,4,5,6,7,8,9},*p=a+3;
printf("%d", *++p);
```

答案： B

解析： `*(ptr)`表示输出指针指向的变量的值； `++p`表示先自增后输出，即`a+4`。


7. 对于下面的程序段，叙述正确的是（ ）。

```c
char s[]="china", *p=s;
```

A. *p与 `s[0]` 相等

B.数组 s 中的内容和指针变量 p 中的内容相等

C. s 和 p 完全相同

D.数组 s 的长度和 p 所指向的字符串长度相等

答案： A

解析：
B： `s`的内容是字符串， `p`的内容是内存地址。
C： `s`是常量指针。
D： `s`的长度比`p`的长度大1 。


8. 下面程序段的运行结果是（ ）。 

```c
char s[] = "language", *p = s;
	while (*p++ != 'u')
	{
		printf("%c", *p - 'a' + 'A');
	}
```

A. LANGUAGE

B. ANGU

C. LANGU

D. LANG


答案： B

解析： 首先，`*p++`为先运算后自增，因此先计算 `*p != 'u'`， 之后`p`自增， 因此第一次输出的字符是 A 而不是 L， 以此类推， 答案为ANGU。


## 填空题
1. 输出一维数组最大元素和最小元素的下标。査找一维数组的最大元素和最小元素的下标，分別存放在函数 main() 的 maxsub 和 minsub 变量中。请填空。
```c
void find(int *, int, int *, int *);
int main(void)
{
	int maxsub, minsub, a[] = {5, 3, 7, 9, 2, 0, 4, 1, 6, 8};
	find(____________);
	printf("maxsub=%d, minsub=%d\n", maxsub, minsub);
	return 0;
}
void find(int *a, int n, int *maxsub, int *minsub)
{
	int i;
	*maxsub = *minsub = 0;
	for (i = 1; i < n; i++)
	{
		if (a[i] > a[*maxsub])
			____________;
		if (a[i] < a[*minsub])
			____________;
	}
}
```


答案：
```c
void find(int *, int, int *, int *);
int main(void)
{
	int maxsub, minsub, a[] = {5, 3, 7, 9, 2, 0, 4, 1, 6, 8};
	find(a, 10, &maxsub, &minsub); // 取maxsub 和 minsub 的地址
	printf("maxsub=%d, minsub=%d\n", maxsub, minsub);
	return 0;
}
void find(int *a, int n, int *maxsub, int *minsub)
{
	int i;
	*maxsub = *minsub = 0;
	for (i = 1; i < n; i++)
	{
		if (a[i] > a[*maxsub])
			*maxsub = i;
		if (a[i] < a[*minsub])
			*minsub = i;
	}
}
```


2. 数组插值。函数 insert() 的功能是在一维数组 a 中将 x 插入到下标为 i （i>=0）的元素前，如果 i>=元素个数，则 x 插入到末尾，元素个数存放在指针 n 所指向的变量中，插入后元素个数加 1 。请填空。
```c
void insert(int a[], int *n, int x, int i)
{
	int j;
	if (________)
	{
		for (j = *n - 1; ________; j--)
			________ = a[j];
	}
	else
	{
		i = *n;
	}
	a[i] = ________;
	(*n)++;
}
```

答案：
```c
void insert(int a[], int *n, int x, int i)
{
	int j;
	if (i < *n) 
	{
		for (j = *n - 1; j >= i; j--)
			a[j+1] = a[j];
	}
	else
	{
		i = *n;
	}
	a[i] = x;
	(*n)++;
}
```


3. 判断回文。先消除输入字符串 s 的前后空格，再判断其是否为“回文”(即字符串正读和倒读都是一样的)， 若是则输出 Yes ，否则输出 No。请填空。

```c
char ch, s[80], *p, *q;
int i, j, n;
gets(s);
p = _________;
while (*p == ' ')
{
	_________;
}
n = strlen(s);
q = _________;
while (*q == ' ')
{
	q--;
}
while (_________ && *p == *q)
{
	p++;
	_________;
}
if (p < q)
	printf("No\n");
else
	printf("Yes\n");
```


答案：
```c
char ch, s[80], *p, *q;
int i, j, n;
gets(s);
p = s;
while (*p == ' ')
{
	p++;
}
n = strlen(s);
q = s + n - 1; // 指针指向数组尾部，从尾部消除空格
while (*q == ' ')
{
	q--;
}
while (p < q && *p == *q) // p >= q 表示两指针相遇
{
	p++;
	q--;
}
if (p < q)
	printf("No\n");
else
	printf("Yes\n");
```


4. 最大字符移位。在字符串 str 中找出最大的字符，将在该字符前的所有字符往后顺序移动一位，再把最大字符放在字符串的第一个位置上。如 " knowedge" 变成 "wknoledge" 。请填空。
```c
char max, str[80], *p = str, *q = str;
gets(p);
max = *(p++);
while (*p != '\0')
{
	if (max < *p)
	{
		max = *p;
		__________;
	}
	p++;
}
p = q;
while (__________)
{
	__________;
	p--;
}
*p = max;
puts(p);
```

答案：
```c
char max, str[80], *p = str, *q = str;
gets(p);
max = *(p++);
while (*p != '\0')
{
	if (max < *p)
	{
		max = *p;
		q = p; 
	}
	p++;
}
p = q;
while (p != str)
{
	*p = *(p - 1); // 后移
	p--;
}
*p = max; // 首位插入max的值
puts(p);
```


5. 字符传送。将字符串 s1 的所有字符传送到字符串 s2 中，要求每传送 3 个字符就再存放一个星号。如字符串 s1 为 "abedefg" ，则字符串 s2 为 `"abe*def*g"`。请填空。

```c
char s1[80], s2[80], *p = s1;
int cnt = 0, k = 0;
gets(p);
while (*p != '\0')
{
	s2[k] = *p;
	k++;
	p++;
	cnt++;
	if (_________)
	{
		s2[k] = '*';
		_________;
		_________;
	}
}
s2[k] = '\0';
puts(s2);
```

答案：
```c
char s1[80], s2[80], *p = s1;
int cnt = 0, k = 0;
gets(p);
while (*p != '\0')
{
	s2[k] = *p;
	k++;
	p++;
	cnt++;
	if (cnt == 3)
	{
		s2[k] = '*';
		k++;
		cnt = 0; // 计数器归零
	}
}
s2[k] = '\0';
puts(s2);
```